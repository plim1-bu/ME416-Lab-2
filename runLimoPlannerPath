function runLimoPlannerPath_MQTT()
% RUNLIMOPLANNERPATH_MQTT - Follow a predefined path using Dubins + Pure Pursuit
% Works with real LIMO hardware using MQTT MoCap feedback

clearvars; close all;

%% ===============================================
%% CONFIGURATION
%% ===============================================

% LIMO / Network Configuration
LIMO_NUMBER = '777';
LIMO_IP_LAST_3 = '101';
CFG.limo_ip_prefix = '192.168.1.158';
CFG.limo_port = 12345;
CFG.mqtt_broker = 'mqtt://rasticvm.lan';

% MoCap origin transformation
CFG.MOCAP_ORIGIN_X = -4.5;
CFG.MOCAP_ORIGIN_Y = 2.7;

% Pure Pursuit Controller Parameters
CFG.LOOKAHEAD_DISTANCE = 0.5;   % [m]
CFG.V_DESIRED = 0.25;           % [m/s]
CFG.MIN_TURNING_RADIUS = 0.3;   % [m]

% Loop Recovery Parameters
CFG.LOOP_RECOVERY_DURATION = 1.0;
CFG.LOOPS_BEFORE_RECOVERY = 2;

% Goal tolerance
CFG.GOAL_POSITION_TOL = 0.10;
CFG.GOAL_HEADING_TOL = deg2rad(10);

% Safety
CFG.MAX_LINEAR_VEL = 0.3;
CFG.MAX_ANGULAR_VEL = deg2rad(60);
CFG.MAX_TIME = 360;

% Control loop timing
CFG.CONTROL_RATE = 20;
CFG.dt = 1/CFG.CONTROL_RATE;

tcp = [];
mqttClient = [];

try
    %% ===============================================
    %% LOAD PLANNER WAYPOINTS
    %% ===============================================
    fprintf('Loading planner path...\n');
    load('phase3_path.mat','rx','ry');
    N = length(rx);
    if length(ry) ~= N
        error('rx and ry must have same length');
    end
    
    % Compute headings between waypoints
    waypoints = zeros(N,3);
    for i = 1:N-1
        dx = rx(i+1) - rx(i);
        dy = ry(i+1) - ry(i);
        theta = atan2(dy, dx);
        waypoints(i,:) = [rx(i), ry(i), theta];
    end
    waypoints(N,:) = [rx(N), ry(N), waypoints(N-1,3)]; % last heading
    
    %% ===============================================
    %% MQTT CONNECTION
    %% ===============================================
    fprintf('Connecting to MQTT broker: %s\n', CFG.mqtt_broker);
    mqttClient = mqttclient(CFG.mqtt_broker);
    subscribe(mqttClient, sprintf("rb/limo%s/pos", LIMO_NUMBER));
    subscribe(mqttClient, sprintf("rb/limo%s/rot", LIMO_NUMBER));
    pause(2); % wait for initial data
    
    % Get initial pose
    [curr_pose, valid] = getRobotPose_MQTT(mqttClient,LIMO_NUMBER,CFG,[],0);
    if ~valid
        error('Cannot read initial MoCap data');
    end
    start_pose = curr_pose;
    
    %% ===============================================
    %% LIMO TCP CONNECTION
    %% ===============================================
    limo_ip = [CFG.limo_ip_prefix LIMO_IP_LAST_3];
    fprintf('Connecting to LIMO TCP: %s:%d\n', limo_ip, CFG.limo_port);
    tcp = tcpclient(limo_ip, CFG.limo_port, 'Timeout', 5);
    write(tcp, uint8('0.00,0.00')); pause(0.5);
    
    %% ===============================================
    %% GENERATE DUBINS PATH FOR ALL WAYPOINTS
    %% ===============================================
    fprintf('Generating Dubins path along waypoints...\n');
    dubinsPathFull = [];
    path_s = 0;
    
    dubinsObj = dubinsConnection('MinTurningRadius', CFG.MIN_TURNING_RADIUS);
    
    for i = 1:N-1
        start_wp = waypoints(i,:);
        goal_wp = waypoints(i+1,:);
        [segObj,~] = connect(dubinsObj,start_wp,goal_wp);
        if isempty(segObj)
            error('Dubins path between waypoints %d-%d failed',i,i+1);
        end
        segPoints = interpolate(segObj{1},0:0.05:segObj{1}.Length);
        if i>1
            % remove duplicate first point
            segPoints = segPoints(2:end,:);
        end
        dubinsPathFull = [dubinsPathFull; segPoints];
    end
    
    path.x = dubinsPathFull(:,1);
    path.y = dubinsPathFull(:,2);
    path.theta = dubinsPathFull(:,3);
    path.s = cumsum([0; sqrt(diff(path.x).^2 + diff(path.y).^2)]);
    
    %% ===============================================
    %% VISUALIZATION SETUP
    %% ===============================================
    fig = figure('Name','LIMO Planner Path Tracker','Position',[100 100 1200 800]);
    plot(path.x,path.y,'b--','LineWidth',2.5); hold on; grid on; axis equal;
    plot(rx,ry,'ko','MarkerFaceColor','g','DisplayName','Planner Waypoints');
    h_robot = plot(start_pose(1),start_pose(2),'ro','MarkerFaceColor','r');
    h_trajectory = plot(start_pose(1),start_pose(2),'r-','LineWidth',2);
    h_lookahead = plot(start_pose(1),start_pose(2),'cs','MarkerFaceColor','c');
    h_heading = quiver(start_pose(1),start_pose(2),0,0,0,'m','LineWidth',2);
    
    %% ===============================================
    %% MAIN CONTROL LOOP
    %% ===============================================
    goal_reached = false;
    prev_pose = start_pose;
    prev_time = 0;
    traj_x = start_pose(1);
    traj_y = start_pose(2);
    loop_count = 0;
    
    % Loop detection
    cumulative_heading_change = 0;
    loop_counter = 0;
    recovery_mode = false;
    recovery_start_time = 0;
    
    start_time = tic;
    while ~goal_reached
        loop_start = tic;
        loop_count = loop_count + 1;
        curr_time = toc(start_time);
        dt = curr_time - prev_time;
        
        % --- Get robot pose
        [curr_pose, valid] = getRobotPose_MQTT(mqttClient,LIMO_NUMBER,CFG,prev_pose,dt);
        if ~valid
            pause(CFG.dt); continue;
        end
        x = curr_pose(1); y = curr_pose(2); theta = curr_pose(3);
        
        % --- Loop detection (same as your original script)
        if loop_count>1
            heading_change = wrapToPi(theta - prev_pose(3));
            cumulative_heading_change = cumulative_heading_change + abs(heading_change);
            if cumulative_heading_change >= 2*pi
                loop_counter = loop_counter + 1;
                cumulative_heading_change = 0;
                if loop_counter >= CFG.LOOPS_BEFORE_RECOVERY
                    recovery_mode = true;
                    recovery_start_time = curr_time;
                    loop_counter = 0;
                end
            end
        end
        prev_pose = curr_pose;
        prev_time = curr_time;
        
        % --- Distance to goal
        dx = path.x(end)-x; dy = path.y(end)-y;
        dist_to_goal = sqrt(dx^2 + dy^2);
        heading_error_to_goal = wrapToPi(path.theta(end)-theta);
        
        if (dist_to_goal < CFG.GOAL_POSITION_TOL) && (abs(heading_error_to_goal)<CFG.GOAL_HEADING_TOL)
            goal_reached = true;
            fprintf('✓ Goal reached!\n');
            break;
        end
        
        % --- Control law
        if recovery_mode
            if curr_time - recovery_start_time >= CFG.LOOP_RECOVERY_DURATION
                recovery_mode = false;
                cumulative_heading_change = 0;
            end
            v_cmd = CFG.V_DESIRED;
            omega = 0;
            lookahead_x = x + 0.5*cos(theta);
            lookahead_y = y + 0.5*sin(theta);
        else
            [lookahead_x, lookahead_y, ~, ~] = findLookaheadPoint(x,y,path,CFG.LOOKAHEAD_DISTANCE);
            alpha = atan2(lookahead_y - y, lookahead_x - x);
            curvature = 2*sin(wrapToPi(alpha - theta))/CFG.LOOKAHEAD_DISTANCE;
            omega = max(-CFG.MAX_ANGULAR_VEL, min(CFG.MAX_ANGULAR_VEL, curvature*CFG.V_DESIRED));
            v_cmd = CFG.V_DESIRED;
        end
        
        % --- Send command
        cmd_str = sprintf('%.2f,%.2f',v_cmd,omega);
        write(tcp,uint8(cmd_str));
        
        % --- Update visualization
        traj_x(end+1) = x; traj_y(end+1) = y;
        set(h_robot,'XData',x,'YData',y);
        set(h_trajectory,'XData',traj_x,'YData',traj_y);
        set(h_lookahead,'XData',lookahead_x,'YData',lookahead_y);
        set(h_heading,'XData',x,'YData',y,'UData',0.3*cos(theta),'VData',0.3*sin(theta));
        drawnow limitrate;
        
        % --- Safety timeout
        if curr_time > CFG.MAX_TIME
            fprintf('✗ Timeout\n'); break;
        end
        
        % --- Maintain loop rate
        elapsed = toc(loop_start);
        if elapsed < CFG.dt
            pause(CFG.dt - elapsed);
        end
    end
    
catch ME
    fprintf('Error: %s\n',ME.message);
end

%% ===============================================
%% CLEANUP
%% ===============================================
if ~isempty(tcp) && isvalid(tcp)
    write(tcp,uint8('0.00,0.00')); pause(0.5); clear tcp;
end
if ~isempty(mqttClient), clear mqttClient; end

fprintf('Script complete.\n\n');

end
